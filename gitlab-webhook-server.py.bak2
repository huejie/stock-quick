#!/usr/bin/env python3
"""
GitLab Webhookæ¥æ”¶æœåŠ¡
ç”¨äºæ¥æ”¶GitLabçš„pushã€merge requestç­‰äº‹ä»¶ï¼Œå¹¶è¿›è¡Œä»£ç å®¡æŸ¥
- æ¥æ”¶MRäº‹ä»¶
- è·å–ä»£ç diff
- é€šè¿‡Claude Codeè¿›è¡Œä»£ç å®¡æŸ¥
- å°†å®¡æŸ¥ç»“æœå‘é€åˆ°é£ä¹¦
- è‡ªåŠ¨å›å¤åˆ°GitLab MRè¯„è®ºåŒº
"""

from fastapi import FastAPI, Request, Header, HTTPException
from fastapi.responses import JSONResponse
import uvicorn
import hmac
import hashlib
import json
import os
import requests
from datetime import datetime
import logging
from pathlib import Path
import subprocess
import time
import re

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# åˆ›å»ºFastAPIåº”ç”¨
app = FastAPI(title="GitLab Webhook Receiver", version="2.0.0")

# Webhook Secret (å»ºè®®ä»ç¯å¢ƒå˜é‡è¯»å–ï¼‰
WEBHOOK_SECRET = None
LOG_FILE = Path("/root/.openclaw/workspace/webhook-logs.jsonl")

# é£ä¹¦é€šçŸ¥ç›®æ ‡
FEISHU_TARGET_USER = "ou_032db2f8e45df3e207b2ea3a0563df9c"

# GitLabé…ç½®
GITLAB_URL = "https://git.iec.io"
GITLAB_TOKEN = "glpat-hO7Kq5QZ-F_5pHpbWsNG9W86MQp1OjJuMgk.01.0z0zuoear"

def verify_signature(payload: bytes, signature: str, secret: str) -> bool:
    """éªŒè¯GitLab webhookç­¾å"""
    if not secret:
        return True

    hash_obj = hmac.new(secret.encode('utf-8'), payload, hashlib.sha1)
    expected_signature = f"sha1={hash_obj.hexdigest()}"
    return hmac.compare_digest(signature, expected_signature)

def log_webhook(event_type: str, data: dict):
    """è®°å½•webhookäº‹ä»¶åˆ°æ—¥å¿—æ–‡ä»¶"""
    log_entry = {
        "timestamp": datetime.utcnow().isoformat(),
        "event_type": event_type,
        "data": data
    }
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(json.dumps(log_entry, ensure_ascii=False) + '\n')

@app.get("/")
async def root():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹"""
    return {
        "status": "running",
        "service": "GitLab Webhook Receiver with Auto Code Review",
        "version": "2.0.0",
        "features": [
            "æ¥æ”¶GitLab webhookäº‹ä»¶",
            "è‡ªåŠ¨è·å–MR diff",
            "AIä»£ç å®¡æŸ¥",
            "é£ä¹¦é€šçŸ¥",
            "è‡ªåŠ¨å›å¤åˆ°GitLab MRè¯„è®ºåŒº"
        ],
        "timestamp": datetime.utcnow().isoformat()
    }

@app.post("/webhook/gitlab")
async def handle_gitlab_webhook(
    request: Request,
    x_gitlab_token: str = Header(None),
    x_gitlab_event: str = Header(None)
):
    """å¤„ç†GitLab webhookè¯·æ±‚"""
    try:
        payload = await request.body()
        data = await request.json()

        # éªŒè¯ç­¾åï¼ˆå¦‚æœé…ç½®äº†secretï¼‰
        if WEBHOOK_SECRET and x_gitlab_token:
            if not verify_signature(payload, x_gitlab_token, WEBHOOK_SECRET):
                logger.warning("Invalid webhook signature")
                raise HTTPException(status_code=403, detail="Invalid signature")

        # è·å–äº‹ä»¶ç±»å‹
        event_type = x_gitlab_event or data.get('object_kind', 'Unknown')

        logger.info(f"Received webhook: {event_type}")

        # è®°å½•webhookäº‹ä»¶
        log_webhook(event_type, data)

        # æ ¹æ®äº‹ä»¶ç±»å‹å¤„ç†
        if event_type == "Push Hook":
            await handle_push_event(data)
        elif event_type == "Merge Request Hook":
            await handle_merge_request_event(data)
        elif event_type == "Tag Push Hook":
            await handle_tag_push_event(data)
        elif event_type == "Pipeline Hook":
            await handle_pipeline_event(data)

        return JSONResponse(
            status_code=200,
            content={"status": "success", "message": f"Webhook received: {event_type}"}
        )

    except json.JSONDecodeError:
        logger.error("Invalid JSON payload")
        raise HTTPException(status_code=400, detail="Invalid JSON")
    except Exception as e:
        logger.error(f"Error processing webhook: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

def get_gitlab_diff(project_id: int, mr_iid: int) -> str:
    """è·å–GitLab MRçš„ä»£ç diff"""
    try:
        url = f"{GITLAB_URL}/api/v4/projects/{project_id}/merge_requests/{mr_iid}/diffs"
        headers = {"PRIVATE-TOKEN": GITLAB_TOKEN}

        response = requests.get(url, headers=headers, timeout=30)

        if response.status_code == 200:
            diffs = response.json()
            # æå–æ‰€æœ‰diffå†…å®¹
            diff_text = ""
            for diff in diffs:
                diff_text += diff.get('diff', '') + "\n\n"

            # é™åˆ¶diffé•¿åº¦
            if len(diff_text) > 6000:
                diff_text = diff_text[:6000] + "\n\n... (diffå·²æˆªæ–­ï¼Œè¶…è¿‡6000å­—ç¬¦)"

            return diff_text
        else:
            logger.error(f"Failed to get diff: {response.status_code}")
            return None

    except Exception as e:
        logger.error(f"Error getting diff: {e}")
        return None

def post_gitlab_mr_comment(project_id: int, mr_iid: int, comment: str) -> bool:
    """
    åœ¨GitLab MRè¯„è®ºåŒºæ·»åŠ è¯„è®º

    å‚æ•°:
        project_id: é¡¹ç›®ID
        mr_iid: MRçš„IIDï¼ˆä¸æ˜¯IDï¼‰
        comment: è¯„è®ºå†…å®¹

    è¿”å›:
        æ˜¯å¦æˆåŠŸ
    """
    try:
        url = f"{GITLAB_URL}/api/v4/projects/{project_id}/merge_requests/{mr_iid}/notes"
        headers = {"PRIVATE-TOKEN": GITLAB_TOKEN}

        data = {
            "body": comment
        }

        response = requests.post(url, headers=headers, json=data, timeout=30)

        if response.status_code == 201:
            logger.info(f"Comment posted to MR {mr_iid} successfully")
            return True
        else:
            logger.error(f"Failed to post comment: {response.status_code} - {response.text}")
            return False

    except Exception as e:
        logger.error(f"Error posting MR comment: {e}")
        return False

def run_claude_code_review(prompt: str) -> str:
    """
    ä½¿ç”¨Claude Codeè¿è¡Œä»£ç å®¡æŸ¥

    å‚æ•°:
        prompt: å®¡æŸ¥æç¤ºè¯

    è¿”å›:
        å®¡æŸ¥ç»“æœï¼ˆæˆ–Noneå¦‚æœå¤±è´¥ï¼‰
    """
    session_name = f"code-review-{int(time.time())}"
    wingman_cmd = [
        '/root/code/claude-code-wingman/claude-wingman.sh',
        '--session', session_name,
        '--workdir', '/tmp',
        '--prompt', prompt
    ]

    try:
        logger.info(f"Claude Code review started: {session_name}")
        logger.info(f"Full command: {' '.join(wingman_cmd)}")

        # ç›´æ¥è¿è¡ŒClaude Codeï¼Œç­‰å¾…å®Œæˆï¼ˆ90ç§’è¶…æ—¶ï¼‰
        process = subprocess.run(
            wingman_cmd,
            capture_output=True,
            text=True,
            timeout=90
        )

        logger.info(f"Process returncode: {process.returncode}")
        logger.info(f"Process timeout: {'yes' if process.returncode is None else 'no'}")
        
        # è¾“å‡ºstderrç”¨äºè°ƒè¯•
        if process.stderr:
            logger.error(f"Process stderr: {process.stderr[:500]}")

        if process.returncode == 0:
            output = process.stdout
            stderr = process.stderr

            # æ·»åŠ è°ƒè¯•æ—¥å¿—
            logger.info(f"Raw stdout length: {len(output) if output else 0} chars")
            logger.info(f"Raw stderr length: {len(stderr) if stderr else 0} chars")
            logger.info(f"Raw stdout preview: {output[:300] if output else 'None'}")

            # å¦‚æœstdoutä¸ºç©ºï¼Œå°è¯•ä½¿ç”¨stderr
            if not output or len(output.strip()) < 10:
                if stderr and len(stderr.strip()) > 10:
                    logger.warning(f"Using stderr as output (stdout empty)")
                    output = stderr
                else:
                    logger.warning(f"Both stdout and stderr are empty or too short")
                    return f"Claude Codeæ— è¾“å‡ºï¼Œå¯èƒ½promptå¤ªçŸ­æˆ–æ¨¡å‹å“åº”ä¸ºç©ºã€‚Stderr: {stderr[:200] if stderr else 'None'}"

            # è¿‡æ»¤æ‰Claude Codeçš„UIè¾“å‡ºï¼Œåªä¿ç•™å®é™…å†…å®¹
            review_lines = []
            skip_patterns = [
                r'Claude Code',
                r'Welcome',
                r'Recent activity',
                r'GLM',
                r'Tips for',
                r'â”€+', r'â”‚', r'â•­', r'â•¯', r'â–', r'â–', r'â–˜', r'â—',
                r'â¯', r'esc', r'model to try', r'\[plugins\]',
                r'System Prompt', r'You can', r'Started server',
                r'Waiting for', r'Application startup',
                r'Uvicorn running', r'Press CTRL',
                r'\[Wingman\]', r'Attaching', r'Monitor',
                r'Commands:', r'Attach:', r'Monitor:', r'Kill:',
                r'Session started'
            ]

            for line in output.split('\n'):
                # è·³è¿‡UIè¾“å‡º
                if any(re.search(pattern, line) for pattern in skip_patterns):
                    continue
                # è·³è¿‡ç©ºè¡Œå’Œçº¯ç¬¦å·è¡Œ
                if not line.strip() or len(line.strip()) < 5:
                    continue
                review_lines.append(line)

            logger.info(f"After filtering: {len(review_lines)} lines, {len(output.split(chr(10)))} total")

            # æå–æœ€å30è¡Œæœ‰æ„ä¹‰çš„å†…å®¹
            review_text = '\n'.join(review_lines[-30:])
            logger.info(f"Final review text length: {len(review_text)} chars, preview: {review_text[:200]}")

            if review_text.strip():
                return review_text
            else:
                return "å®¡æŸ¥å®Œæˆï¼Œä½†æœªèƒ½æå–è¯¦ç»†å†…å®¹ã€‚"
        else:
            logger.error(f"Claude Code failed: {process.stderr}")
            return f"Claude Codeæ‰§è¡Œå¤±è´¥: {process.stderr}"

    except subprocess.TimeoutExpired:
        logger.error("Claude Code review timeout")
        return "å®¡æŸ¥è¶…æ—¶ï¼Œä»£ç å˜æ›´è¾ƒå¤§ã€‚"
    except Exception as e:
        logger.error(f"Claude Code review error: {e}")
        return f"å®¡æŸ¥å¤±è´¥: {str(e)}"

async def code_review(diff: str, mr_title: str, user: str, project: str) -> tuple[str, str]:
    """
    ä½¿ç”¨Claude Codeè¿›è¡Œä»£ç å®¡æŸ¥

    å‚æ•°:
        diff: ä»£ç diff
        mr_title: MRæ ‡é¢˜
        user: ç”¨æˆ·å
        project: é¡¹ç›®å

    è¿”å›:
        (é£ä¹¦æ¶ˆæ¯æ ¼å¼, GitLabè¯„è®ºæ ¼å¼)
    """
    if not diff:
        feishu_msg = f"âš ï¸ **ä»£ç å®¡æŸ¥å¤±è´¥**\n\næ— æ³•è·å–ä»£ç diffï¼Œè·³è¿‡å®¡æŸ¥ã€‚"
        gitlab_comment = "## âš ï¸ ä»£ç å®¡æŸ¥å¤±è´¥\n\næ— æ³•è·å–ä»£ç diffï¼Œè·³è¿‡å®¡æŸ¥ã€‚"
        return feishu_msg, gitlab_comment

    try:
        # æ„é€ å®¡æŸ¥æç¤ºè¯ï¼ˆä½¿ç”¨ç”¨æˆ·æä¾›çš„ä¸“ä¸šæç¤ºè¯ï¼‰
        review_prompt = f"""ä½ æ˜¯ä¸€ä½èµ„æ·±çš„ä¼ä¸šçº§ä»£ç å®¡æŸ¥ä¸“å®¶ï¼Œéœ€è¦å¯¹GitLab/Merge Requestä¸­çš„ä»£ç è¿›è¡Œä¸“ä¸šå®¡æŸ¥ã€‚è¯·éµå¾ªä»¥ä¸‹è§„åˆ™è¾“å‡ºè¯„è®ºï¼š

1. è¯„è®ºé£æ ¼ï¼šå‹å¥½ä¸”ä¸“ä¸šï¼Œå…ˆè‚¯å®šä¼˜ç‚¹ï¼ˆå¦‚æœ‰ï¼‰ï¼Œå†æŒ‡å‡ºé—®é¢˜ï¼Œæœ€åç»™å‡ºå…·ä½“å¯è½åœ°çš„æ”¹è¿›æ–¹æ¡ˆï¼Œé¿å…ä»…è¯´"ä»£ç æœ‰é—®é¢˜"

2. å®¡æŸ¥ä¼˜å…ˆçº§ï¼šå…ˆå…³æ³¨**åŠŸèƒ½æ€§/å®‰å…¨æ€§/æ€§èƒ½**ï¼ˆé˜»æ–­çº§é—®é¢˜ï¼‰ï¼Œå†å…³æ³¨**ä»£ç é£æ ¼/å¯è¯»æ€§/å¯ç»´æŠ¤æ€§**ï¼ˆä¼˜åŒ–çº§é—®é¢˜ï¼‰

3. é—®é¢˜æè¿°ï¼šæ˜ç¡®æŒ‡å‡ºé—®é¢˜ä½ç½®ï¼ˆæ–‡ä»¶+è¡Œå·ï¼‰ã€é—®é¢˜ç±»å‹ã€æ½œåœ¨é£é™©ã€å…·ä½“ä¿®æ”¹å»ºè®®

4. è¯­è¨€é€‚é…ï¼šæ ¹æ®ä»£ç è¯­è¨€ï¼ˆPython/Java/JS/Goç­‰ï¼‰ä½¿ç”¨å¯¹åº”è¯­è¨€çš„æœ€ä½³å®è·µ

5. é¿å…æ— æ•ˆè¯„è®ºï¼šä¸çº ç»“äºçº¯æ ¼å¼ï¼ˆå¦‚ç©ºæ ¼/æ¢è¡Œï¼‰ï¼Œé™¤éå½±å“å¯è¯»æ€§ï¼›ä¸è´¨ç–‘ä¸šåŠ¡é€»è¾‘ï¼ˆé™¤éæœ‰æ˜æ˜¾é”™è¯¯ï¼‰ï¼Œèšç„¦æŠ€æœ¯å®ç°

**MRä¿¡æ¯ï¼š**
- é¡¹ç›®ï¼š{project}
- ç”¨æˆ·ï¼š{user}
- æ ‡é¢˜ï¼š{mr_title}

**ä»£ç diffï¼š**
```diff
{diff}
```

è¯·ä»¥ç»“æ„åŒ–çš„æ–¹å¼è¾“å‡ºå®¡æŸ¥ç»“æœï¼ŒåŒ…æ‹¬ï¼š
- æ€»ä½“è¯„ä»·ï¼ˆ1-2å¥è¯ï¼‰
- å‘ç°çš„é—®é¢˜ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼Œæ¯ä¸ªé—®é¢˜è¯´æ˜ä½ç½®ã€ç±»å‹ã€é£é™©ã€å»ºè®®ï¼‰
- ä¼˜ç‚¹ï¼ˆå¯é€‰ï¼‰

ä¿æŒç®€æ´ä¸“ä¸šï¼Œä¸è¶…è¿‡500å­—ã€‚"""

        # ä½¿ç”¨Claude Codeè¿›è¡Œä»£ç å®¡æŸ¥
        review_result = run_claude_code_review(review_prompt)

        # å¤„ç†å®¡æŸ¥ç»“æœ
        if review_result and review_result != "Claude Codeæ‰§è¡Œè¶…æ—¶":
            # Claude CodeæˆåŠŸè¿”å›
            feishu_msg = f"""ğŸ” **ä»£ç å®¡æŸ¥æŠ¥å‘Š**

ğŸ“¦ é¡¹ç›®ï¼š{project}
ğŸ‘¤ æäº¤è€…ï¼š{user}
ğŸ“‹ MRï¼š{mr_title}

---

{review_result}

ğŸ’¡ *æœ¬è¯„è®ºç”±å°Kçš„ä»£ç å®¡æŸ¥ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ*"""

            gitlab_comment = f"""## ğŸ” AIä»£ç å®¡æŸ¥

**é¡¹ç›®**: {project}  
**æäº¤è€…**: {user}  
**MR**: {mr_title}

---

{review_result}

---

*æœ¬è¯„è®ºç”±å°Kçš„ä»£ç å®¡æŸ¥ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ*"""

            return feishu_msg, gitlab_comment
        else:
            # Claude Codeå¤±è´¥ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯
            feishu_msg = f"""ğŸ“‹ **ä»£ç å®¡æŸ¥é€šçŸ¥**

ğŸ“¦ é¡¹ç›®ï¼š{project}
ğŸ‘¤ æäº¤è€…ï¼š{user}
ğŸ“‹ MRï¼š{mr_title}

âš ï¸ AIå®¡æŸ¥æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·æ‰‹åŠ¨è¿›è¡Œä»£ç å®¡æŸ¥ã€‚

é”™è¯¯ä¿¡æ¯ï¼š{review_result if review_result else 'æœªçŸ¥é”™è¯¯'}"""

            gitlab_comment = f"""## ğŸ“‹ ä»£ç å®¡æŸ¥é€šçŸ¥

AIå®¡æŸ¥æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·æ‰‹åŠ¨è¿›è¡Œä»£ç å®¡æŸ¥ã€‚

**é”™è¯¯ä¿¡æ¯**: {review_result if review_result else 'æœªçŸ¥é”™è¯¯'}"""

            return feishu_msg, gitlab_comment

    except Exception as e:
        logger.error(f"Code review error: {e}")
        feishu_msg = f"âš ï¸ **ä»£ç å®¡æŸ¥å¤±è´¥**\n\nå®¡æŸ¥è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼š{str(e)}"
        gitlab_comment = f"## âš ï¸ ä»£ç å®¡æŸ¥å¤±è´¥\n\nå®¡æŸ¥è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼š{str(e)}"
        return feishu_msg, gitlab_comment
        
        # ===== å®‰å…¨æ€§æ£€æŸ¥ï¼ˆé˜»æ–­çº§ï¼‰=====
        # SQLæ³¨å…¥é£é™©
        if "SELECT *" in diff.upper() and "WHERE" in diff.upper() and "f\"" in diff:
            blocking_issues.append({
                "type": "å®‰å…¨æ€§",
                "issue": "å¯èƒ½çš„SQLæ³¨å…¥é£é™©",
                "location": "æ•°æ®åº“æŸ¥è¯¢ä»£ç ",
                "risk": "ç”¨æˆ·è¾“å…¥ç›´æ¥æ‹¼æ¥åˆ°SQLè¯­å¥ä¸­ï¼Œå¯èƒ½å¯¼è‡´SQLæ³¨å…¥æ”»å‡»",
                "suggestion": "ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢æˆ–ORMæ¡†æ¶ï¼Œå¦‚ï¼š`session.query(User).filter(User.id == user_id)`"
            })
        
        # XSSé£é™©
        if "innerHTML" in diff or "dangerouslySetInnerHTML" in diff:
            blocking_issues.append({
                "type": "å®‰å…¨æ€§",
                "issue": "XSSè·¨ç«™è„šæœ¬æ”»å‡»é£é™©",
                "location": "DOMæ“ä½œä»£ç ",
                "risk": "ç›´æ¥æ¸²æŸ“ç”¨æˆ·è¾“å…¥çš„HTMLå¯èƒ½å¯¼è‡´æ¶æ„è„šæœ¬æ‰§è¡Œ",
                "suggestion": "ä½¿ç”¨`textContent`æ›¿ä»£`innerHTML`ï¼Œæˆ–ä½¿ç”¨DOMPurifyç­‰åº“è¿›è¡ŒHTMLè¿‡æ»¤"
            })
        
        # æ•æ„Ÿä¿¡æ¯æ³„éœ²
        if any(keyword in diff.lower() for keyword in ["password", "secret", "token", "api_key", "private_key"]):
            if "=" in diff and any(quote in diff for quote in ['"', "'"]):
                blocking_issues.append({
                    "type": "å®‰å…¨æ€§",
                    "issue": "æ•æ„Ÿä¿¡æ¯ç¡¬ç¼–ç ",
                    "location": "é…ç½®/å¸¸é‡å®šä¹‰",
                    "risk": "å¯†é’¥ã€Tokenç­‰æ•æ„Ÿä¿¡æ¯ä¸åº”ç¡¬ç¼–ç åœ¨ä»£ç ä¸­",
                    "suggestion": "ç§»åˆ°ç¯å¢ƒå˜é‡æˆ–é…ç½®æ–‡ä»¶ï¼š`const API_KEY = process.env.API_KEY`"
                })
        
        # ===== æ€§èƒ½æ£€æŸ¥ï¼ˆé˜»æ–­çº§ï¼‰=====
        # N+1æŸ¥è¯¢é—®é¢˜
        if "for " in diff and ".find(" in diff and ".all()" in diff:
            blocking_issues.append({
                "type": "æ€§èƒ½",
                "issue": "å¯èƒ½çš„N+1æŸ¥è¯¢é—®é¢˜",
                "location": "å¾ªç¯ä¸­çš„æ•°æ®åº“æŸ¥è¯¢",
                "risk": "åœ¨å¾ªç¯ä¸­æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜",
                "suggestion": "ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢æˆ–é¢„åŠ è½½ï¼š`User.query.filter(User.id.in_(user_ids)).all()`"
            })
        
        # å¤§æ–‡ä»¶ä¸Šä¼ æ— é™åˆ¶
        if "upload" in diff.lower() and "max_size" not in diff.lower():
            blocking_issues.append({
                "type": "æ€§èƒ½",
                "issue": "æ–‡ä»¶ä¸Šä¼ ç¼ºå°‘å¤§å°é™åˆ¶",
                "location": "æ–‡ä»¶ä¸Šä¼ å¤„ç†",
                "risk": "å¯èƒ½å¯¼è‡´æœåŠ¡å™¨èµ„æºè€—å°½",
                "suggestion": "æ·»åŠ æ–‡ä»¶å¤§å°é™åˆ¶ï¼š`maxFileSize: 10 * 1024 * 1024`ï¼ˆ10MBï¼‰"
            })
        
        # ä¸å¿…è¦çš„å¾ªç¯åµŒå¥—
        if diff.count("for ") > 2 or diff.count("while ") > 1:
            blocking_issues.append({
                "type": "æ€§èƒ½",
                "issue": "å¤šå±‚åµŒå¥—å¾ªç¯",
                "location": "å¾ªç¯é€»è¾‘",
                "risk": "æ—¶é—´å¤æ‚åº¦å¯èƒ½è¿‡é«˜ï¼Œå½±å“æ€§èƒ½",
                "suggestion": "è€ƒè™‘ä½¿ç”¨Map/Setä¼˜åŒ–æŸ¥æ‰¾ï¼Œæˆ–é‡æ„ä¸ºå•å±‚å¾ªç¯"
            })
        
        # ===== åŠŸèƒ½æ€§æ£€æŸ¥ï¼ˆé˜»æ–­çº§ï¼‰=====
        # ç©ºæŒ‡é’ˆ/æœªå®šä¹‰æ£€æŸ¥
        if any(method in diff for method in [".map(", ".filter(", ".reduce(", ".forEach("]):
            if "?" not in diff and "null" not in diff and "undefined" not in diff:
                optimization_issues.append({
                    "type": "åŠŸèƒ½æ€§",
                    "issue": "å¯èƒ½çš„ç©ºå€¼å¼•ç”¨",
                    "location": "æ•°ç»„/å¯¹è±¡æ“ä½œ",
                    "risk": "æ•°æ®ä¸ºnull/undefinedæ—¶ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯",
                    "suggestion": "ä½¿ç”¨å¯é€‰é“¾ï¼š`data?.map(item => ...)` æˆ–æ·»åŠ ç©ºå€¼æ£€æŸ¥"
                })
        
        # Promiseæœªå¤„ç†
        if ".then(" in diff and ".catch(" not in diff and "await" not in diff:
            blocking_issues.append({
                "type": "åŠŸèƒ½æ€§",
                "issue": "Promiseé”™è¯¯æœªå¤„ç†",
                "location": "å¼‚æ­¥ä»£ç ",
                "risk": "å¼‚æ­¥æ“ä½œå¤±è´¥æ—¶å¯èƒ½å¯¼è‡´æœªæ•è·çš„Promise rejection",
                "suggestion": "æ·»åŠ `.catch()`å¤„ç†é”™è¯¯ï¼Œæˆ–ä½¿ç”¨`try/catch`åŒ…è£¹await"
            })
        
        # èµ„æºæœªé‡Šæ”¾
        if "open(" in diff or "connect(" in diff:
            if "close(" not in diff and "finally" not in diff:
                blocking_issues.append({
                    "type": "åŠŸèƒ½æ€§",
                    "issue": "èµ„æºæœªæ­£ç¡®é‡Šæ”¾",
                    "location": "æ–‡ä»¶/ç½‘ç»œæ“ä½œ",
                    "risk": "å¯èƒ½å¯¼è‡´èµ„æºæ³„æ¼",
                    "suggestion": "ä½¿ç”¨`with`è¯­å¥æˆ–`try/finally`ç¡®ä¿èµ„æºé‡Šæ”¾"
                })
        
        # ===== Vueç›¸å…³æ£€æŸ¥ =====
        if ".vue" in diff:
            # Vueç»„ä»¶å‘½å
            if "export default" in diff and "name:" not in diff:
                optimization_issues.append({
                    "type": "å¯ç»´æŠ¤æ€§",
                    "issue": "Vueç»„ä»¶ç¼ºå°‘nameå±æ€§",
                    "location": "ç»„ä»¶å®šä¹‰",
                    "risk": "å½±å“è°ƒè¯•å’ŒVue DevToolsä¸­çš„ç»„ä»¶è¯†åˆ«",
                    "suggestion": "æ·»åŠ ç»„ä»¶nameï¼š`export default { name: 'UserProfile', ... }`"
                })
            
            # PropséªŒè¯
            if "props:" in diff:
                if "type:" not in diff and "validator:" not in diff:
                    optimization_issues.append({
                        "type": "åŠŸèƒ½æ€§",
                        "issue": "Propsç¼ºå°‘ç±»å‹å®šä¹‰",
                        "location": "Propså£°æ˜",
                        "risk": "æ— æ³•å¯¹propsè¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œå¯èƒ½å¯¼è‡´è¿è¡Œæ—¶é”™è¯¯",
                        "suggestion": "æ·»åŠ Propsç±»å‹ï¼š`props: { userId: { type: String, required: true } }`"
                    })
            
            # :keyè­¦å‘Š
            if "v-for" in diff and ":key" not in diff and "v-bind:key" not in diff:
                blocking_issues.append({
                    "type": "åŠŸèƒ½æ€§",
                    "issue": "v-forç¼ºå°‘:keyå±æ€§",
                    "location": "åˆ—è¡¨æ¸²æŸ“",
                    "risk": "å¯èƒ½å¯¼è‡´Vueæ¸²æŸ“é”™è¯¯å’Œæ€§èƒ½é—®é¢˜",
                    "suggestion": "æ·»åŠ å”¯ä¸€keyï¼š`v-for=\"item in list\" :key=\"item.id\"`"
                })
            
            # computed vs methods
            if "methods:" in diff and "computed:" in diff:
                optimization_issues.append({
                    "type": "æ€§èƒ½",
                    "issue": "å¯ä½¿ç”¨computedæ›¿ä»£methods",
                    "location": "æ–¹æ³•å®šä¹‰",
                    "risk": "methodsæ¯æ¬¡è°ƒç”¨éƒ½ä¼šé‡æ–°è®¡ç®—ï¼Œcomputedæœ‰ç¼“å­˜",
                    "suggestion": "å¯¹äºæ´¾ç”Ÿæ•°æ®ï¼Œä¼˜å…ˆä½¿ç”¨computedå±æ€§ä»¥æé«˜æ€§èƒ½"
                })
            
            advantages.append("ä½¿ç”¨äº†Vueæ¡†æ¶ï¼Œç»„ä»¶åŒ–å¼€å‘")
        
        # ===== TypeScriptç›¸å…³æ£€æŸ¥ =====
        if ".ts" in diff or ".tsx" in diff:
            # ç±»å‹å®šä¹‰
            if ": any" in diff or "any[]" in diff:
                optimization_issues.append({
                    "type": "ä»£ç è´¨é‡",
                    "issue": "ä½¿ç”¨äº†anyç±»å‹",
                    "location": "ç±»å‹æ ‡æ³¨",
                    "risk": "å¤±å»TypeScriptçš„ç±»å‹æ£€æŸ¥ä¼˜åŠ¿",
                    "suggestion": "ä½¿ç”¨å…·ä½“ç±»å‹æˆ–unknownï¼š`const data: unknown = ...`"
                })
            
            if "interface" in diff or "type " in diff:
                advantages.append("æ­£ç¡®å®šä¹‰äº†TypeScriptç±»å‹ï¼Œæé«˜ä»£ç å¥å£®æ€§")
            
            # ç±»å‹å¯¼å…¥
            if "import" in diff and "from" in diff and ".ts" in diff:
                advantages.append("ä½¿ç”¨TypeScriptå¼€å‘ï¼Œç±»å‹å®‰å…¨")
        
        # ===== Reactç›¸å…³æ£€æŸ¥ =====
        if ".jsx" in diff or ".tsx" in diff:
            # Hooksè§„åˆ™
            if "useEffect" in diff:
                effect_code = diff.split("useEffect")[1].split("}")[0] if len(diff.split("useEffect")) > 1 else ""
                if "return" not in effect_code and "cleanup" not in effect_code.lower():
                    optimization_issues.append({
                        "type": "åŠŸèƒ½æ€§",
                        "issue": "useEffectå¯èƒ½ç¼ºå°‘æ¸…ç†å‡½æ•°",
                        "location": "useEffect",
                        "risk": "å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼",
                        "suggestion": "è¿”å›æ¸…ç†å‡½æ•°ï¼š`useEffect(() => { ... return () => cleanup() }, [])`"
                    })
            
            # Propsè§£æ„
            if "props." in diff and "const {" not in diff:
                optimization_issues.append({
                    "type": "å¯è¯»æ€§",
                    "issue": "å»ºè®®è§£æ„props",
                    "location": "ç»„ä»¶å‚æ•°",
                    "risk": "é¢‘ç¹ä½¿ç”¨props.xxxé™ä½å¯è¯»æ€§",
                    "suggestion": "è§£æ„ä½¿ç”¨ï¼š`const { userId, userName } = props`"
                })
            
            # Keyå±æ€§
            if ".map(" in diff and "key=" not in diff:
                blocking_issues.append({
                    "type": "åŠŸèƒ½æ€§",
                    "issue": "Reactåˆ—è¡¨æ¸²æŸ“ç¼ºå°‘keyå±æ€§",
                    "location": "mapæ¸²æŸ“",
                    "risk": "å¯èƒ½å¯¼è‡´Reactæ¸²æŸ“é”™è¯¯å’Œæ€§èƒ½é—®é¢˜",
                    "suggestion": "æ·»åŠ å”¯ä¸€keyï¼š`items.map(item => <div key={item.id}>...</div>)`"
                })
            
            advantages.append("ä½¿ç”¨Reactæ¡†æ¶ï¼Œç»„ä»¶åŒ–æ€ç»´")
        
        # ===== CSS/æ ·å¼ç›¸å…³æ£€æŸ¥ =====
        if ".css" in diff or ".scss" in diff or ".less" in diff or "<style" in diff:
            # !importantä½¿ç”¨
            if "!important" in diff:
                optimization_issues.append({
                    "type": "å¯ç»´æŠ¤æ€§",
                    "issue": "ä½¿ç”¨äº†!important",
                    "location": "CSSæ ·å¼",
                    "risk": "é™ä½æ ·å¼å¯ç»´æŠ¤æ€§ï¼Œéš¾ä»¥è¦†ç›–",
                    "suggestion": "æé«˜é€‰æ‹©å™¨ä¼˜å…ˆçº§æˆ–ä½¿ç”¨CSS Modulesæ›¿ä»£"
                })
            
            # å†…è”æ ·å¼
            if "style=\"" in diff or "style='" in diff or "style={{" in diff:
                optimization_issues.append({
                    "type": "å¯ç»´æŠ¤æ€§",
                    "issue": "åŒ…å«å†…è”æ ·å¼",
                    "location": "JSX/æ¨¡æ¿",
                    "risk": "æ ·å¼åˆ†æ•£ï¼Œéš¾ä»¥ç»Ÿä¸€ç®¡ç†",
                    "suggestion": "ç§»åˆ°CSSæ–‡ä»¶ã€CSS Modulesæˆ–styled-components"
                })
            
            # class vs className
            if "class=" in diff and ".jsx" in diff:
                blocking_issues.append({
                    "type": "åŠŸèƒ½æ€§",
                    "issue": "JSXä¸­ä½¿ç”¨äº†classè€ŒéclassName",
                    "location": "JSXå±æ€§",
                    "risk": "classæ˜¯JavaScriptä¿ç•™å­—ï¼Œä¼šå¯¼è‡´è¯­æ³•é”™è¯¯",
                    "suggestion": "ä½¿ç”¨classNameï¼š`<div className=\"container\">`"
                })
        
        # ===== JavaScript/TypeScripté€šç”¨æ£€æŸ¥ =====
        # varä½¿ç”¨
        if "var " in diff:
            optimization_issues.append({
                "type": "ä»£ç è´¨é‡",
                "issue": "ä½¿ç”¨äº†varå£°æ˜å˜é‡",
                "location": "å˜é‡å£°æ˜",
                "risk": "varæœ‰ä½œç”¨åŸŸæå‡é—®é¢˜ï¼Œlet/constæ›´å®‰å…¨",
                "suggestion": "ä½¿ç”¨letï¼ˆå¯å˜ï¼‰æˆ–constï¼ˆä¸å¯å˜ï¼‰æ›¿ä»£var"
            })
        
        # == vs ===
        if " == " in diff or " != " in diff:
            optimization_issues.append({
                "type": "ä»£ç è´¨é‡",
                "issue": "ä½¿ç”¨äº†å¼±ç›¸ç­‰(==)",
                "location": "æ¯”è¾ƒæ“ä½œ",
                "risk": "å¯èƒ½å‘ç”Ÿç±»å‹è½¬æ¢ï¼Œå¯¼è‡´æ„å¤–ç»“æœ",
                "suggestion": "ä½¿ç”¨å¼ºç›¸ç­‰(===)é¿å…ç±»å‹è½¬æ¢"
            })
        
        # console.log
        if "console.log" in diff:
            optimization_issues.append({
                "type": "ä»£ç è´¨é‡",
                "issue": "åŒ…å«console.logè°ƒè¯•è¯­å¥",
                "location": "è°ƒè¯•ä»£ç ",
                "risk": "ç”Ÿäº§ç¯å¢ƒä¸åº”åŒ…å«è°ƒè¯•æ—¥å¿—",
                "suggestion": "ç§»é™¤æˆ–ä½¿ç”¨æ¡ä»¶ç¼–è¯‘ï¼š`if (process.env.DEBUG) console.log(...)`"
            })
        
        # TODO/FIXME
        if "TODO" in diff or "FIXME" in diff:
            optimization_issues.append({
                "type": "å¯ç»´æŠ¤æ€§",
                "issue": "ä»£ç ä¸­åŒ…å«TODO/FIXMEæ ‡è®°",
                "location": "æ³¨é‡Š",
                "risk": "å¯èƒ½é—æ¼æœªå®Œæˆçš„å·¥ä½œ",
                "suggestion": "åˆ›å»ºIssueè·Ÿè¸ªï¼Œæˆ–åŠæ—¶å¤„ç†"
            })
        
        # ç¡¬ç¼–ç URL
        if "http://" in diff or "https://" in diff:
            optimization_issues.append({
                "type": "å¯ç»´æŠ¤æ€§",
                "issue": "åŒ…å«URLç¡¬ç¼–ç ",
                "location": "APIè°ƒç”¨/èµ„æºå¼•ç”¨",
                "risk": "ç¯å¢ƒåˆ‡æ¢æ—¶éœ€è¦ä¿®æ”¹ä»£ç ",
                "suggestion": "ç§»åˆ°é…ç½®æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡ï¼š`const API_URL = process.env.API_BASE_URL`"
            })
        
        # importé¡ºåº
        import_lines = [line for line in diff.split('\n') if 'import ' in line]
        if len(import_lines) > 3:
            optimization_issues.append({
                "type": "ä»£ç é£æ ¼",
                "issue": "importè¯­å¥è¾ƒå¤šï¼Œå»ºè®®æŒ‰è§„èŒƒåˆ†ç»„",
                "location": "importå£°æ˜",
                "risk": "å½±å“ä»£ç å¯è¯»æ€§",
                "suggestion": "æŒ‰è§„èŒƒæ’åºï¼šç¬¬ä¸‰æ–¹åº“ -> ç»„ä»¶ -> å·¥å…·å‡½æ•° -> æ ·å¼"
            })
        
        # ä»£ç å˜æ›´å¤§å°
        if len(diff) > 5000:
            optimization_issues.append({
                "type": "å¯ç»´æŠ¤æ€§",
                "issue": f"ä»£ç å˜æ›´è¾ƒå¤§ï¼ˆ{len(diff)}å­—ç¬¦ï¼‰",
                "location": "æ•´ä½“MR",
                "risk": "å¤§MRéš¾ä»¥å®¡æŸ¥ï¼Œå®¹æ˜“å¼•å…¥bug",
                "suggestion": "å»ºè®®æ‹†åˆ†æˆå¤šä¸ªå°MRï¼Œæ¯ä¸ªMRä¸“æ³¨å•ä¸€åŠŸèƒ½"
            })
        
        # ===== æµ‹è¯•ç›¸å…³æ£€æŸ¥ =====
        if "test" in diff.lower() or "spec" in diff.lower():
            advantages.append("åŒ…å«äº†æµ‹è¯•ä»£ç ï¼Œå€¼å¾—ç§°èµ")
            
            if "describe" in diff or "test(" in diff or "it(" in diff:
                advantages.append("ä½¿ç”¨äº†æµ‹è¯•æ¡†æ¶ï¼Œä¿è¯ä»£ç è´¨é‡")
        
        # ===== æ–‡æ¡£æ³¨é‡Šæ£€æŸ¥ =====
        if '"""' in diff or "'''" in diff or "/**" in diff:
            advantages.append("ä»£ç åŒ…å«æ–‡æ¡£æ³¨é‡Šï¼Œæœ‰åˆ©äºå›¢é˜Ÿåä½œ")
        
        # ===== æ€§èƒ½ä¼˜åŒ–å»ºè®® =====
        if "forEach" in diff and "map" in diff:
            optimization_issues.append({
                "type": "æ€§èƒ½",
                "issue": "forEachå’Œmapæ··ç”¨",
                "location": "æ•°ç»„æ“ä½œ",
                "risk": "forEachä¸è¿”å›å€¼ï¼Œå¯èƒ½ä¸æ˜¯é¢„æœŸè¡Œä¸º",
                "suggestion": "å¦‚éœ€è½¬æ¢æ•°æ®ç”¨mapï¼Œå¦‚éœ€éå†ç”¨forEach"
            })
        
        if "async" in diff and "await" not in diff:
            optimization_issues.append({
                "type": "ä»£ç è´¨é‡",
                "issue": "å‡½æ•°æ ‡è®°ä¸ºasyncä½†æœªä½¿ç”¨await",
                "location": "å‡½æ•°å®šä¹‰",
                "risk": "å¯èƒ½æ˜¯è¯¯æ ‡è®°ï¼Œæˆ–é—æ¼await",
                "suggestion": "æ£€æŸ¥æ˜¯å¦éœ€è¦awaitï¼Œæˆ–ç§»é™¤asyncæ ‡è®°"
            })
        
        # ===== ç°ä»£å‰ç«¯ç‰¹æ€§ =====
        if "?. " in diff or "?.(" in diff or "?? " in diff:
            advantages.append("ä½¿ç”¨äº†å¯é€‰é“¾å’Œç©ºå€¼åˆå¹¶ï¼Œä»£ç æ›´ç®€æ´å®‰å…¨")
        
        if "const " in diff and "let " not in diff:
            advantages.append("ä¼˜å…ˆä½¿ç”¨constå£°æ˜å˜é‡ï¼Œä»£ç æ›´å®‰å…¨")
        
        # æ„å»ºä¸“ä¸šå®¡æŸ¥ç»“æœ
        review_parts = []
        
        # æ€»ä½“è¯„ä»·ï¼ˆç®€æ´ï¼‰
        total_issues = len(blocking_issues) + len(optimization_issues)
        if total_issues == 0:
            review_parts.append("## æ€»ä½“è¯„ä»·")
            review_parts.append("ä»£ç è´¨é‡è‰¯å¥½ï¼Œæœªå‘ç°æ˜æ˜¾é—®é¢˜ã€‚âœ…")
        else:
            review_parts.append("## æ€»ä½“è¯„ä»·")
            if len(blocking_issues) > 0:
                review_parts.append(f"å‘ç°**{len(blocking_issues)}ä¸ªé˜»æ–­çº§é—®é¢˜**éœ€è¦ä¿®å¤ï¼Œ")
            if len(optimization_issues) > 0:
                review_parts.append(f"**{len(optimization_issues)}ä¸ªä¼˜åŒ–å»ºè®®**ä¾›å‚è€ƒã€‚")
            review_parts.append("å»ºè®®ä¼˜å…ˆå¤„ç†é˜»æ–­çº§é—®é¢˜åå†åˆå¹¶ã€‚")
        
        # é˜»æ–­çº§é—®é¢˜ï¼ˆåŠŸèƒ½æ€§/å®‰å…¨æ€§/æ€§èƒ½ï¼‰
        if blocking_issues:
            review_parts.append("\n## ğŸ”´ é˜»æ–­çº§é—®é¢˜ï¼ˆå¿…é¡»ä¿®å¤ï¼‰")
            for i, issue in enumerate(blocking_issues, 1):
                # æå–å…·ä½“ä»£ç ä¿¡æ¯
                line_info = extract_line_info(diff, issue)
                if line_info:
                    review_parts.append(f"\n### {i}. {issue['type']}ï¼š{issue['issue']}")
                    review_parts.append(f"**ä½ç½®**: `{line_info['file']}` ç¬¬{line_info['line']}è¡Œ")
                    review_parts.append(f"**ä»£ç **: `{line_info['code']}`")
                else:
                    review_parts.append(f"\n### {i}. {issue['type']}ï¼š{issue['issue']}")
                review_parts.append(f"- **é£é™©**: {issue['risk']}")
                review_parts.append(f"- **ä¿®æ”¹å»ºè®®**: {issue['suggestion']}")
        
        # ä¼˜åŒ–çº§é—®é¢˜ï¼ˆä»£ç é£æ ¼/å¯è¯»æ€§/å¯ç»´æŠ¤æ€§ï¼‰
        if optimization_issues:
            review_parts.append("\n## ğŸ’¡ ä¼˜åŒ–å»ºè®®ï¼ˆå»ºè®®æ”¹è¿›ï¼‰")
            for i, issue in enumerate(optimization_issues, 1):
                # æå–å…·ä½“ä»£ç ä¿¡æ¯
                line_info = extract_line_info(diff, issue)
                if line_info:
                    review_parts.append(f"\n### {i}. {issue['type']}ï¼š{issue['issue']}")
                    review_parts.append(f"**ä½ç½®**: `{line_info['file']}` ç¬¬{line_info['line']}è¡Œ")
                    review_parts.append(f"**ä»£ç **: `{line_info['code']}`")
                else:
                    review_parts.append(f"\n### {i}. {issue['type']}ï¼š{issue['issue']}")
                review_parts.append(f"- **è¯´æ˜**: {issue['risk']}")
                review_parts.append(f"- **ä¿®æ”¹å»ºè®®**: {issue['suggestion']}")
        
        # å¦‚æœæ²¡æœ‰ä»»ä½•å‘ç°
        if not blocking_issues and not optimization_issues:
            review_parts.append("\n## è¯´æ˜")
            review_parts.append("ä»£ç å˜æ›´è¾ƒå°ï¼Œæœªå‘ç°æ˜æ˜¾é—®é¢˜ã€‚ä¿æŒè‰¯å¥½çš„ç¼–ç ä¹ æƒ¯ï¼")
        
        review_result = "\n".join(review_parts)

        feishu_msg = f"""ğŸ” **ä»£ç å®¡æŸ¥æŠ¥å‘Š**

ğŸ“¦ é¡¹ç›®ï¼š{project}
ğŸ‘¤ æäº¤è€…ï¼š{user}
ğŸ“‹ MRï¼š{mr_title}

---

{review_result}

ğŸ’¡ *æœ¬è¯„è®ºç”±å°Kçš„ä»£ç å®¡æŸ¥ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ*"""

        gitlab_comment = f"""## ğŸ” AIä»£ç å®¡æŸ¥

**é¡¹ç›®**: {project}  
**æäº¤è€…**: {user}  
**MR**: {mr_title}

---

{review_result}

---

*æœ¬è¯„è®ºç”±å°Kçš„ä»£ç å®¡æŸ¥ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ*"""

        return feishu_msg, gitlab_comment

    except Exception as e:
        logger.error(f"Code review error: {e}")
        feishu_msg = f"âš ï¸ **ä»£ç å®¡æŸ¥å¤±è´¥**\n\nå®¡æŸ¥è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼š{str(e)}"
        gitlab_comment = f"## âš ï¸ ä»£ç å®¡æŸ¥å¤±è´¥\n\nå®¡æŸ¥è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼š{str(e)}"
        return feishu_msg, gitlab_comment

async def handle_push_event(data: dict):
    """å¤„ç†Pushäº‹ä»¶"""
    project = data.get('project', {}).get('name', 'Unknown')
    ref = data.get('ref', '')
    user = data.get('user_name', 'Unknown')
    commits = data.get('total_commits_count', 0)

    logger.info(f"Push event: {user} pushed {commits} commits to {ref} in {project}")

async def handle_merge_request_event(data: dict):
    """å¤„ç†Merge Requestäº‹ä»¶"""
    mr = data.get('object_attributes', {})
    action = mr.get('action', 'Unknown')
    title = mr.get('title', 'Unknown')
    user = data.get('user', {}).get('name', 'Unknown')
    project = data.get('project', {})
    project_id = project.get('id')
    project_name = project.get('name', 'Unknown')
    mr_iid = mr.get('iid')

    logger.info(f"MR event: {user} {action} MR: {title}")

    # åªå¯¹æ–°çš„MRï¼ˆopen actionï¼‰è¿›è¡Œä»£ç å®¡æŸ¥
    if action == 'open' and mr_iid:
        logger.info(f"Starting code review for MR {mr_iid}")
        try:
            # è·å–ä»£ç diff
            diff = get_gitlab_diff(project_id, mr_iid)

            if diff:
                # è¿›è¡Œä»£ç å®¡æŸ¥
                feishu_msg, gitlab_comment = await code_review(diff, title, user, project_name)

                # å‘é€å®¡æŸ¥ç»“æœåˆ°é£ä¹¦
                send_raw_feishu_message(feishu_msg)
                logger.info(f"Code review sent to Feishu for MR {mr_iid}")

                # è‡ªåŠ¨å›å¤åˆ°GitLab MRè¯„è®ºåŒº
                success = post_gitlab_mr_comment(project_id, mr_iid, gitlab_comment)
                if success:
                    logger.info(f"Code review posted to GitLab MR {mr_iid}")
                else:
                    logger.error(f"Failed to post review to GitLab MR {mr_iid}")
            else:
                logger.warning(f"Failed to get diff for MR {mr_iid}")

        except Exception as e:
            logger.error(f"Error during code review: {e}")

async def handle_tag_push_event(data: dict):
    """å¤„ç†Tag Pushäº‹ä»¶"""
    project = data.get('project', {}).get('name', 'Unknown')
    ref = data.get('ref', '')
    user = data.get('user_name', 'Unknown')

    logger.info(f"Tag push event: {user} pushed tag {ref} in {project}")

async def handle_pipeline_event(data: dict):
    """å¤„ç†Pipelineäº‹ä»¶"""
    pipeline = data.get('object_attributes', {})
    status = pipeline.get('status', 'Unknown')
    source = pipeline.get('source', 'Unknown')

    logger.info(f"Pipeline event: Pipeline {status} from {source}")

def extract_line_info(diff: str, issue: dict) -> dict:
    """
    ä»diffä¸­æå–é—®é¢˜ç›¸å…³çš„ä»£ç è¡Œä¿¡æ¯
    è¿”å›: {file: str, line: int, code: str} æˆ– None
    """
    try:
        lines = diff.split('\n')
        current_file = None
        current_line = 0
        
        for i, line in enumerate(lines):
            # è§£ædiffæ–‡ä»¶å¤´
            if line.startswith('+++ b/'):
                current_file = line[6:].strip()
                current_line = 0
                continue
            
            # è§£ædiffä½ç½®ä¿¡æ¯ @@ -start,count +start,count @@
            if line.startswith('@@'):
                match = re.search(r'\+(\d+)', line)
                if match:
                    current_line = int(match.group(1))
                continue
            
            # è·³è¿‡å…¶ä»–diffå¤´éƒ¨
            if line.startswith('diff --git') or line.startswith('index ') or line.startswith('---'):
                continue
            
            # æ£€æŸ¥å…·ä½“çš„ä»£ç é—®é¢˜
            if not line.startswith(('+', '-')):
                # ä¸æ˜¯æ–°å¢æˆ–åˆ é™¤çš„è¡Œï¼Œè·³è¿‡
                if current_line > 0:
                    current_line += 1
                continue
            
            # æå–å®é™…ä»£ç ï¼ˆå»æ‰+/-ç¬¦å·ï¼‰
            code_line = line[1:].strip() if len(line) > 1 else ""
            
            # æ ¹æ®é—®é¢˜ç±»å‹ç²¾ç¡®åŒ¹é…
            is_problem = False
            
            if issue['type'] == 'ä»£ç è´¨é‡' and 'console.log' in issue['issue']:
                if 'console.log' in code_line:
                    is_problem = True
            
            elif issue['type'] == 'ä»£ç è´¨é‡' and 'var ' in issue['issue']:
                # æ£€æŸ¥æ˜¯å¦ä»¥varå¼€å¤´ï¼ˆvaråè·Ÿç©ºæ ¼ï¼‰
                if code_line.startswith('var '):
                    is_problem = True
            
            elif issue['type'] == 'ä»£ç è´¨é‡' and '==' in issue['issue']:
                if ' == ' in code_line or ' != ' in code_line:
                    is_problem = True
            
            elif issue['type'] == 'å®‰å…¨æ€§' and 'XSS' in issue['issue']:
                if 'innerHTML' in code_line or 'dangerouslySetInnerHTML' in code_line:
                    is_problem = True
            
            elif issue['type'] == 'å®‰å…¨æ€§' and 'æ•æ„Ÿä¿¡æ¯' in issue['issue']:
                if any(kw in code_line.lower() for kw in ['password', 'secret', 'token', 'api_key']):
                    if '=' in code_line and any(q in code_line for q in ['"', "'"]):
                        is_problem = True
            
            elif issue['type'] == 'åŠŸèƒ½æ€§' and 'v-for' in issue['issue']:
                if 'v-for' in code_line and 'key=' not in code_line and ':key' not in code_line:
                    is_problem = True
            
            elif issue['type'] == 'åŠŸèƒ½æ€§' and 'nameå±æ€§' in issue['issue']:
                if 'export default' in code_line and current_file and current_file.endswith('.vue'):
                    # æ£€æŸ¥åç»­å‡ è¡Œæ˜¯å¦æœ‰name
                    has_name = False
                    for j in range(i+1, min(i+10, len(lines))):
                        if 'name:' in lines[j]:
                            has_name = True
                            break
                        if lines[j].startswith('@@') or lines[j].startswith('+++'):
                            break
                    if not has_name:
                        is_problem = True
            
            elif issue['type'] == 'å¯ç»´æŠ¤æ€§' and 'TODO' in issue['issue']:
                if 'TODO' in code_line or 'FIXME' in code_line:
                    is_problem = True
            
            elif issue['type'] == 'å¯ç»´æŠ¤æ€§' and '!important' in issue['issue']:
                if '!important' in code_line:
                    is_problem = True
            
            elif issue['type'] == 'å¯ç»´æŠ¤æ€§' and 'ç¡¬ç¼–ç ' in issue['issue']:
                if 'http://' in code_line or 'https://' in code_line:
                    is_problem = True
            
            # å¦‚æœæ‰¾åˆ°é—®é¢˜ï¼Œè¿”å›è¯¦ç»†ä¿¡æ¯
            if is_problem and current_file and current_line > 0:
                # é™åˆ¶ä»£ç é•¿åº¦
                display_code = code_line if len(code_line) <= 80 else code_line[:80] + "..."
                return {
                    'file': current_file,
                    'line': current_line,
                    'code': display_code
                }
            
            # æ›´æ–°è¡Œå·
            if line.startswith('+') and not line.startswith('+++'):
                current_line += 1
        
        return None
        
    except Exception as e:
        logger.warning(f"Failed to extract line info: {e}")
        return None

def send_raw_feishu_message(message: str):
    """ç›´æ¥å‘é€é£ä¹¦æ¶ˆæ¯ï¼ˆç”¨äºä»£ç å®¡æŸ¥ç»“æœï¼‰"""
    try:
        # è®¾ç½®å®Œæ•´çš„ç¯å¢ƒå˜é‡
        env = os.environ.copy()
        env['PATH'] = '/root/.nvm/versions/node/v22.22.0/bin:' + env.get('PATH', '')
        env['NVM_DIR'] = '/root/.nvm'

        # ä½¿ç”¨ç»å¯¹è·¯å¾„è°ƒç”¨OpenClaw
        openclaw_path = '/root/.nvm/versions/node/v22.22.0/bin/openclaw'
        result = subprocess.run(
            [openclaw_path, 'message', 'send',
             '--channel', 'feishu',
             '--account', 'xiaok',
             '--target', f'user:{FEISHU_TARGET_USER}',
             '--message', message],
            capture_output=True,
            text=True,
            timeout=15,
            env=env
        )
        if result.returncode == 0:
            logger.info(f"Raw Feishu message sent successfully")
        else:
            logger.error(f"Raw Feishu message failed: {result.stderr}")
    except subprocess.TimeoutExpired:
        logger.error("Raw Feishu message timeout")
    except Exception as e:
        logger.error(f"Failed to send raw Feishu message: {str(e)}")

if __name__ == "__main__":
    logger.info("=" * 60)
    logger.info("GitLab Webhook Server v2.0.0 starting...")
    logger.info("Features:")
    logger.info("  - æ¥æ”¶GitLab webhookäº‹ä»¶")
    logger.info("  - è‡ªåŠ¨è·å–MR diff")
    logger.info("  - AIä»£ç å®¡æŸ¥")
    logger.info("  - é£ä¹¦é€šçŸ¥")
    logger.info("  - è‡ªåŠ¨å›å¤åˆ°GitLab MRè¯„è®ºåŒº")
    logger.info("=" * 60)

    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8888,
        log_level="info"
    )
